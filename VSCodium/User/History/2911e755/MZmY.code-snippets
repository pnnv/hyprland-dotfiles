{
  // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  "Print to console": {
    "prefix": "sssvcpp",
    "body": [
      "// $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
      "#include <bits/stdc++.h>",
      "using namespace std;\n",
      "#define fastio() ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n",
      "#define IOtext freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);",
      "#define PI (3.141592653589)",
      "#define M 1000000007",
      "#define pb push_back",
      "#define f first",
      "#define s second",
      "#define foreach(i, j, k, in) for(int i=j;i<k;i+=in)",
      "#define rforeach(i, j, k, in) for(int i=j;i>=k;i-=in)",
      "#define rep(i,j) foreach(i,0,j,1)",
      "#define rrep(i,j) rforeach(i,j,0,1)",
      "#define set_bits(x) __builtin_popcountll(x)",
      "#define zero_bits(x) __builtin_ctzll(x)",
      "#define sz(s) (int)(s.size())",
      "#define Num_of_Digits(n) ((int)log10(n) + 1)",
      "#define inint(x) int x; cin>>x;",
      "#define inll(x) long long int x; cin>>x;",
      "#define instr(x) string x; cin>>x;",
      "#define all(x) x.begin(), x.end()",
      "#define os(x) cout << x << \" \";",
      "#define out(x) cout << x << endl;",
      "#define MAX(x) *max_element(all(x))",
      "#define MIN(x) *min_element(all(x))",
      "#define SUM(x) accumulate(all(x), 0LL)",
      "#define COUNT(x,u) count(all(x), u)",
      "#define B break",
      "#define C continue",
      "#define py cout<<\"YES\"<<endl",
      "#define pn cout<<\"NO\"<<endl",
      "#define pm cout<<\"-1\"<<endl",
      "#define ps(x,y) fixed<<setprecision(y)<<x\n",
      "//Typedef",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef long double lld;",
      "typedef pair<int, int> pi;",
      "typedef pair<ll, ll> pl;",
      "typedef vector<int> vi;",
      "typedef vector<ll> vl;",
      "typedef vector<pi> vpi;",
      "typedef vector<pl> vpl;",
      "typedef vector<vi> vvi;",
      "typedef vector<vl> vvl;",
      "typedef map<int,int> mii;",
      "typedef set<int> st;\n",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x) cerr<<#x<<\" \";_print(x); cerr<<endl;",
      "#else",
      "#define debug(x)",
      "#endif\n",
      "void _print(ll t) {cerr << t;}",
      "void _print(int t) {cerr << t;}",
      "void _print(string t) {cerr << t;}",
      "void _print(char t) {cerr << t;}",
      "void _print(double t) {cerr << t;}\n",
      "// Operator overloads",
      "template<typename T> // cin >> vector<T>",
      "istream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}",
      "template<typename T> // cout << vector<T>",
      "ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }",
      "template<typename T, typename V> // cout << map<T,T>",
      "ostream& operator<<(ostream &ostream, const map<T,V> &c) { for (auto &it : c) cout << it.first << \" \" << it.second<<endl; return ostream; }\n",
      "//Sorting",
      "bool sorta(const pair<int,int> &a,const pair<int,int> &b){return (a.second < b.second);}",
      "bool sortd(const pair<int,int> &a,const pair<int,int> &b){return (a.second > b.second);}\n",
      "//Bits",
      "string decToBinary(int n){string s=\"\";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}",
      "ll binaryToDecimal(string n){string num = n;ll dec_value = 0;int base = 1;int len = num.length();for(int i = len - 1; i >= 0; i--){if (num[i] == '1')dec_value += base;base = base * 2;}return dec_value;}\n",
      "//Check",
      "bool isPrime(ll n){if(n<=1)return false;if(n<=3)return true;if(n%2==0n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0n%(i+2)==0)return false;return true;}",
      "bool isPowerOfTwo(int n){if(n==0)return false;return (ceil(log2(n)) == floor(log2(n)));}",
      "bool isPerfectSquare(ll x){if (x >= 0) {ll sr = sqrt(x);return (sr * sr == x);}return false;}\n",
      "//Constants",
      "vector <ll> primes;",
      "vector <bool> is_prime;\n",
      "// Mathematical functions",
      "void Sieve(int n){ is_prime.assign(n + 1, true); is_prime[0] = is_prime[1] = false; for(ll i = 2; i * i <= n; i++) if(is_prime[i]) for(ll j = i * i; j <= n; j += i) is_prime[j] = false;}",
      "void get_primes(int n){ for(int i = 2; i <= n; i++)  if(is_prime[i])  primes.push_back(i); }",
      "ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
      "ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
      "ll gcd(ll a, ll b){if (b == 0)return a;return gcd(b, a % b);} //__gcd ",
      "ll lcm(ll a, ll b){return (a/gcd(a,b)*b);}",
      "ll moduloMultiplication(ll a,ll b,ll mod){ll res = 0;a %= mod;while (b){if (b & 1)res = (res + a) % mod;b >>= 1;}return res;}",
      "ll powermod(ll x, ll y, ll p){ll res = 1;x = x % p;if (x == 0) return 0;while (y > 0){if (y & 1)res = (res*x) % p;y = y>>1;x = (x*x) % p;}return res;}",
      "ll modinv(ll p,ll q){ll ex;ex=M-2;while (ex) {if (ex & 1) {p = (p * q) % M;}q = (q * q) % M;ex>>= 1;}return p;}\n",
      "void solve()",
      "{",
      "\t$0",
      "}\n\n",
      "int32_t main()",
      "{",
      "\tfastio()",
      "\tint t;",
      "\tcin>>t;",
      "\twhile(t--)",
      "\t{",
      "\t\tsolve();",
      "\t}",
      "\treturn 0;",
      "}"
    ],
    "description": "Log output to console"
  },
  "cp template": {
    "prefix": "vcpp",
    "body": [
      "// $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define fastio() ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);",
      "",
      "#define IOtext freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);",
      "#define PI (3.141592653589)",
      "#define M 1000000007",
      "#define pb push_back",
      "#define f first",
      "#define s second",
      "#define foreach(i, j, k, in) for(int i=j;i<k;i+=in)",
      "#define rforeach(i, j, k, in) for(int i=j;i>=k;i-=in)",
      "#define rep(i,j) foreach(i,0,j,1)",
      "#define rrep(i,j) rforeach(i,j,0,1)",
      "#define set_bits(x) __builtin_popcountll(x)",
      "#define zero_bits(x) __builtin_ctzll(x)",
      "#define sz(s) (int)(s.size())",
      "#define Num_of_Digits(n) ((int)log10(n) + 1)",
      "#define inint(x) int x; cin>>x;",
      "#define inll(x) long long int x; cin>>x;",
      "#define instr(x) string x; cin>>x;",
      "#define all(x) x.begin(), x.end()",
      "#define os(x) cout << x << \" \";",
      "#define out(x) cout << x << endl;",
      "#define MAX(x) *max_element(all(x))",
      "#define MIN(x) *min_element(all(x))",
      "#define SUM(x) accumulate(all(x), 0LL)",
      "#define COUNT(x,u) count(all(x), u)",
      "#define B break",
      "#define C continue",
      "#define py cout<<\"YES\"<<endl",
      "#define pn cout<<\"NO\"<<endl",
      "#define pm cout<<\"-1\"<<endl",
      "#define ps(x,y) fixed<<setprecision(y)<<x",
      "",
      "//Typedef",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef long double lld;",
      "typedef pair<int, int> pi;",
      "typedef pair<ll, ll> pl;",
      "typedef vector<int> vi;",
      "typedef vector<ll> vl;",
      "typedef vector<pi> vpi;",
      "typedef vector<pl> vpl;",
      "typedef vector<vi> vvi;",
      "typedef vector<vl> vvl;",
      "typedef map<int,int> mii;",
      "typedef set<int> st;",
      "",
      "#ifndef ONLINE_JUDGE",
      "#define debug(x) cerr<<#x<<\" \";_print(x); cerr<<endl;",
      "#else",
      "#define debug(x)",
      "#endif",
      "",
      "void _print(ll t) {cerr << t;}",
      "void _print(int t) {cerr << t;}",
      "void _print(string t) {cerr << t;}",
      "void _print(char t) {cerr << t;}",
      "void _print(double t) {cerr << t;}",
      "",
      "// Operator overloads",
      "template<typename T> // cin >> vector<T>",
      "istream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}",
      "template<typename T> // cout << vector<T>",
      "ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }",
      "template<typename T, typename V> // cout << map<T,T>",
      "ostream& operator<<(ostream &ostream, const map<T,V> &c) { for (auto &it : c) cout << it.first << \" \" << it.second<<endl; return ostream; }",
      "",
      "//Sorting",
      "bool sorta(const pair<int,int> &a,const pair<int,int> &b){return (a.second < b.second);}",
      "bool sortd(const pair<int,int> &a,const pair<int,int> &b){return (a.second > b.second);}",
      "",
      "//Bits",
      "string decToBinary(int n){string s=\"\";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}",
      "ll binaryToDecimal(string n){string num = n;ll dec_value = 0;int base = 1;int len = num.length();for(int i = len - 1; i >= 0; i--){if (num[i] == '1')dec_value += base;base = base * 2;}return dec_value;}",
      "",
      "//Check",
      "bool isPrime(ll n){if(n<=1)return false;if(n<=3)return true;if(n%2==0n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0n%(i+2)==0)return false;return true;}",
      "bool isPowerOfTwo(int n){if(n==0)return false;return (ceil(log2(n)) == floor(log2(n)));}",
      "bool isPerfectSquare(ll x){if (x >= 0) {ll sr = sqrt(x);return (sr * sr == x);}return false;}",
      "",
      "//Constants",
      "vector <ll> primes;",
      "vector <bool> is_prime;",
      "",
      "// Mathematical functions",
      "void Sieve(int n){ is_prime.assign(n + 1, true); is_prime[0] = is_prime[1] = false; for(ll i = 2; i * i <= n; i++) if(is_prime[i]) for(ll j = i * i; j <= n; j += i) is_prime[j] = false;}",
      "void get_primes(int n){ for(int i = 2; i <= n; i++)  if(is_prime[i])  primes.push_back(i); }",
      "ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
      "ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
      "ll gcd(ll a, ll b){if (b == 0)return a;return gcd(b, a % b);} //__gcd ",
      "ll lcm(ll a, ll b){return (a/gcd(a,b)*b);}",
      "ll moduloMultiplication(ll a,ll b,ll mod){ll res = 0;a %= mod;while (b){if (b & 1)res = (res + a) % mod;b >>= 1;}return res;}",
      "ll powermod(ll x, ll y, ll p){ll res = 1;x = x % p;if (x == 0) return 0;while (y > 0){if (y & 1)res = (res*x) % p;y = y>>1;x = (x*x) % p;}return res;}",
      "ll modinv(ll p,ll q){ll ex;ex=M-2;while (ex) {if (ex & 1) {p = (p * q) % M;}q = (q * q) % M;ex>>= 1;}return p;}",
      "",
      "void solve() {$0}",
      "",
      "",
      "int32_t main() {",
      "  fastio()",
      "  int t; cin>>t;",
      "  while(t--) solve();",
      "  return 0;",
      "}"
    ],
    "description": "cp template"
  },
  "lazy segtree": {
    "prefix": "lazy",
    "body": [
      "#ifdef _MSC_VER",
      "#include <intrin.h>",
      "#endif",
      "#if __cplusplus >= 202002L",
      "#include <bit>",
      "#endif",
      "namespace atc {",
      "namespace internal {",
      "#if __cplusplus >= 202002L",
      "using std::bit_ceil;",
      "#else",
      "unsigned int bit_ceil(unsigned int n) {",
      "  unsigned int x = 1;",
      "  while (x < (unsigned int)(n)) x *= 2;",
      "  return x;",
      "}",
      "#endif",
      "int countr_zero(unsigned int n) {",
      "#ifdef _MSC_VER",
      "  unsigned long index;",
      "  _BitScanForward(&index, n);",
      "  return index;",
      "#else",
      "  return __builtin_ctz(n);",
      "#endif",
      "}",
      "constexpr int countr_zero_constexpr(unsigned int n) {",
      "  int x = 0;",
      "  while (!(n & (1 << x))) x++;",
      "  return x;",
      "}",
      "} // namespace internal",
      "} // namespace atc",
      "namespace atc {",
      "#if __cplusplus >= 201703L",
      "template <class S, auto op, auto e, class F, auto mapping, auto composition, auto id>",
      "struct lazy_segtree {",
      "  static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,",
      "                \"op must work as S(S, S)\");",
      "  static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,",
      "                \"e must work as S()\");",
      "  static_assert(",
      "      std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,",
      "      \"mapping must work as F(F, S)\");",
      "  static_assert(",
      "      std::is_convertible_v<decltype(composition), std::function<F(F, F)>>,",
      "      \"compostiion must work as F(F, F)\");",
      "  static_assert(std::is_convertible_v<decltype(id), std::function<F()>>,",
      "                \"id must work as F()\");",
      "",
      "#else",
      "template <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S),",
      "          F (*composition)(F, F), F (*id)()>",
      "struct lazy_segtree {",
      "#endif",
      "public:",
      "  lazy_segtree() : lazy_segtree(0) {}",
      "  explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}",
      "  explicit lazy_segtree(const std::vector<S> &v) : _n(int(v.size())) {",
      "    size = (int)internal::bit_ceil((unsigned int)(_n));",
      "    log = internal::countr_zero((unsigned int)size);",
      "    d = std::vector<S>(2 * size, e());",
      "    lz = std::vector<F>(size, id());",
      "    for (int i = 0; i < _n; i++) d[size + i] = v[i];",
      "    for (int i = size - 1; i >= 1; i--) update(i);",
      "  }",
      "",
      "  void set(int p, S x) {",
      "    assert(0 <= p && p < _n); p += size;",
      "    for (int i = log; i >= 1; i--) push(p >> i);",
      "    d[p] = x;",
      "    for (int i = 1; i <= log; i++) update(p >> i);",
      "  }",
      "",
      "  S get(int p) {",
      "    assert(0 <= p && p < _n); p += size;",
      "    for (int i = log; i >= 1; i--) push(p >> i);",
      "    return d[p];",
      "  }",
      "  S prod(int l, int r) {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    if (l == r) return e();",
      "    l += size; r += size;",
      "",
      "    for (int i = log; i >= 1; i--) {",
      "      if (((l >> i) << i) != l) push(l >> i);",
      "      if (((r >> i) << i) != r) push((r - 1) >> i);",
      "    }",
      "",
      "    S sml = e(), smr = e();",
      "    while (l < r) {",
      "      if (l & 1) sml = op(sml, d[l++]);",
      "      if (r & 1) smr = op(d[--r], smr);",
      "      l >>= 1; r >>= 1;",
      "    }",
      "    return op(sml, smr);",
      "  }",
      "",
      "  S all_prod() { return d[1]; }",
      "",
      "  void apply(int p, F f) {",
      "    assert(0 <= p && p < _n); p += size;",
      "    for (int i = log; i >= 1; i--) push(p >> i);",
      "    d[p] = mapping(f, d[p]);",
      "    for (int i = 1; i <= log; i++) update(p >> i);",
      "  }",
      "  void apply(int l, int r, F f) {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    if (l == r) return;",
      "    l += size; r += size;",
      "    for (int i = log; i >= 1; i--) {",
      "      if (((l >> i) << i) != l) push(l >> i);",
      "      if (((r >> i) << i) != r) push((r - 1) >> i);",
      "    }",
      "    {",
      "      int l2 = l, r2 = r;",
      "      while (l < r) {",
      "        if (l & 1) all_apply(l++, f);",
      "        if (r & 1) all_apply(--r, f);",
      "        l >>= 1; r >>= 1;",
      "      }",
      "      l = l2; r = r2;",
      "    }",
      "    for (int i = 1; i <= log; i++) {",
      "      if (((l >> i) << i) != l) update(l >> i);",
      "      if (((r >> i) << i) != r) update((r - 1) >> i);",
      "    }",
      "  }",
      "  template <bool (*g)(S)> int max_right(int l) {",
      "    return max_right(l, [](S x) { return g(x); });",
      "  }",
      "  template <class G> int max_right(int l, G g) {",
      "    assert(0 <= l && l <= _n);",
      "    assert(g(e()));",
      "    if (l == _n) return _n;",
      "    l += size;",
      "    for (int i = log; i >= 1; i--) push(l >> i);",
      "    S sm = e();",
      "    do {",
      "      while (l % 2 == 0) l >>= 1;",
      "      if (!g(op(sm, d[l]))) {",
      "        while (l < size) {",
      "          push(l);",
      "          l = (2 * l);",
      "          if (g(op(sm, d[l]))) {",
      "            sm = op(sm, d[l]); l++;",
      "          }",
      "        }",
      "        return l - size;",
      "      }",
      "      sm = op(sm, d[l]); l++;",
      "    } while ((l & -l) != l);",
      "    return _n;",
      "  }",
      "",
      "  template <bool (*g)(S)> int min_left(int r) {",
      "    return min_left(r, [](S x) { return g(x); });",
      "  }",
      "  template <class G> int min_left(int r, G g) {",
      "    assert(0 <= r && r <= _n);",
      "    assert(g(e()));",
      "    if (r == 0) return 0;",
      "    r += size;",
      "    for (int i = log; i >= 1; i--) push((r - 1) >> i);",
      "    S sm = e();",
      "    do {",
      "      r--;",
      "      while (r > 1 && (r % 2)) r >>= 1;",
      "      if (!g(op(d[r], sm))) {",
      "        while (r < size) {",
      "          push(r); r = (2 * r + 1);",
      "          if (g(op(d[r], sm))) {",
      "            sm = op(d[r], sm); r--;",
      "          }",
      "        }",
      "        return r + 1 - size;",
      "      }",
      "      sm = op(d[r], sm);",
      "    } while ((r & -r) != r);",
      "    return 0;",
      "  }",
      "",
      "private:",
      "  int _n, size, log;",
      "  std::vector<S> d; std::vector<F> lz;",
      "  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
      "  void all_apply(int k, F f) {",
      "    d[k] = mapping(f, d[k]);",
      "    if (k < size) lz[k] = composition(f, lz[k]);",
      "  }",
      "  void push(int k) {",
      "    all_apply(2 * k, lz[k]); all_apply(2 * k + 1, lz[k]); lz[k] = id();",
      "  }",
      "};",
      "}"
    ],
    "description": "lazy segtree"
  },

  "atc dsu": {
    "prefix": "dsu",
    "body": [
      "struct dsu {",
      "public:",
      "  dsu() : _n(0) {}",
      "  explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}",
      "",
      "  int merge(int a, int b) {",
      "    assert(0 <= a && a < _n);",
      "    assert(0 <= b && b < _n);",
      "    int x = leader(a), y = leader(b);",
      "    if (x == y) return x;",
      "    if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);",
      "    parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x;",
      "    return x;",
      "  }",
      "",
      "  bool same(int a, int b) {",
      "    assert(0 <= a && a < _n); assert(0 <= b && b < _n);",
      "    return leader(a) == leader(b);",
      "  }",
      "",
      "  int leader(int a) {",
      "    assert(0 <= a && a < _n);",
      "    if (parent_or_size[a] < 0) return a;",
      "    return parent_or_size[a] = leader(parent_or_size[a]);",
      "  }",
      "",
      "  int size(int a) {",
      "    assert(0 <= a && a < _n);",
      "    return -parent_or_size[leader(a)];",
      "  }",
      "",
      "  std::vector<std::vector<int>> groups() {",
      "    std::vector<int> leader_buf(_n), group_size(_n);",
      "    for (int i = 0; i < _n; i++) {",
      "      leader_buf[i] = leader(i); group_size[leader_buf[i]]++;",
      "    }",
      "    std::vector<std::vector<int>> result(_n);",
      "    for (int i = 0; i < _n; i++) {",
      "      result[i].reserve(group_size[i]);",
      "    }",
      "    for (int i = 0; i < _n; i++) {",
      "      result[leader_buf[i]].push_back(i);",
      "    }",
      "    result.erase(",
      "        std::remove_if(result.begin(), result.end(),",
      "                       [&](const std::vector<int> &v) { return v.empty(); }),",
      "        result.end());",
      "    return result;",
      "  }",
      "",
      "private:",
      "  int _n;",
      "  std::vector<int> parent_or_size;",
      "};",
    ],
    "description": "atc dsu"
  },

  "Hashed String": {
    "prefix": "hashstring",
    "body": [
      "class HashedString {",
      "private:",
      "  static const ll M = (1LL << 61) - 1;",
      "  static const ll B;",
      "  static vector<ll> pow;",
      "  vector<ll> p_hash;",
      "  __int128 mul(ll a, ll b) { return (__int128)a * b; }",
      "  ll mod_mul(ll a, ll b) { return mul(a, b) % M; }",
      "public:",
      "  HashedString(const string &s) : p_hash(s.size() + 1) {",
      "    while (pow.size() < s.size()) ",
      "      pow.push_back(mod_mul(pow.back(), B));",
      "    p_hash[0] = 0;",
      "    for (int i = 0; i < s.size(); i++)",
      "      p_hash[i + 1] = (mul(p_hash[i], B) + s[i]) % M;",
      "    ",
      "  }",
      "  ll get_hash(int start, int end) {",
      "    ll raw_val = p_hash[end + 1] - mod_mul(p_hash[start], pow[end - start + 1]);",
      "    return (raw_val + M) % M;",
      "  }",
      "};",
      "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());",
      "vector<ll> HashedString::pow = {1};",
      "const ll HashedString::B = uniform_int_distribution<ll>(0, M - 1)(rng);",
      "int freq_target[26], freq_curr[26];"
    ],
    "description": "Hashed String"
  },


  // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }

  "i/o and o/p from a file, to a file": {
    "prefix": "fiop",
    "body": [
      "freopen(\"io.txt\", \"r\", stdin);",
      "freopen(\"op.txt\", \"w\", stdout);"
    ],
    "description": "i/o and o/p from a file, to a file"
  },

  "cp default": {
    "prefix": "cpdef",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "void solve() {}",
      "",
      "int main(void) {",
      "  ios::sync_with_stdio(0);",
      "  cin.tie(0);",
      "",
      "  int t;",
      "  cin >> t;",
      "  while (t--) {",
      "    solve();",
      "  }",
      "}"
    ],
    "description": "cp default"
  },

  "cp default with fiop": {
    "prefix": "fcpdef",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <cstdio>",
      "using namespace std;",
      "",
      "void solve() {}",
      "",
      "int main(void) {",
      "  ",
      "  freopen(\"io.txt\", \"r\", stdin);",
      "  freopen(\"op.txt\", \"w\", stdout);",
      "",
      "  ios::sync_with_stdio(0);",
      "  cin.tie(0);",
      "",
      "  int t;",
      "  cin >> t;",
      "  while (t--) {",
      "    solve();",
      "  }",
      "}"
    ],
    "description": "cp default with fiop"
  },

  "cses": {
    "prefix": "cses",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int32_t main(void) {",
      "  ios::sync_with_stdio(0);",
      "  cin.tie(0);",
      "  ",
      "}"
    ],
    "description": "cses"
  },

  "CP default": {
    "prefix": "mew",
    "body": [

      // "// $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "typedef long long ll;",
      "",
      "void snu() {$0}",
      "",
      "int32_t main() {",
      "\tios::sync_with_stdio(false); cin.tie(0);",
      "\tint t; cin >> t;",
      "\twhile(t--) snu();",
      "}"
    ],
    "description": "CP default"
  },

  "Print Command Output": {
    "prefix": "sex",
    "body": [
      "/*",
        "#!/bin/bash",
        "output=$(ls -l)",
        "echo \"$output\"",
      "*/",
    ],
    "description": "Execute a command and print its output"
  },

  "pbds": {
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template<class K>",
	  "using oset = tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;"
    ],
    "description": "pbds"
  },

  "vector <int>": {
    "prefix": "vi",
    "body": [
      "vector <int>"
    ],
    "description": "vector <int> "
  },

  "vector <ll>": {
    "prefix": "vll",
    "body": [
      "vector <ll> "
    ],
    "description": "vector <ll>"
  },

  "vector <>": {
    "prefix": "vec",
    "body": [
      "vector <${1:a}> ${2:2}"
    ],
    "description": "vector <>"
  },

  "map <int, int>": {
    "prefix": "mii",
    "body": [
      "map <int, int> "
    ],
    "description": "map <int, int>"
  },
  
  "map <ll, ll>": {
    "prefix": "mll",
    "body": [
      "map <ll, ll> "
    ],
    "description": "map <ll, ll>"
  },

  "pair <int, int>": {
    "prefix": "pii",
    "body": [
      "pair <int, int> "
    ],
    "description": "pair <int, int>"
  },
  
  "pair <ll, ll>": {
    "prefix": "pll",
    "body": [
      "pair <ll, ll> "
    ],
    "description": "pair <ll, ll>"
  },

  "print vector": {
    "prefix": "vout",
    "body": [
      "for(auto i: ${1:a}) cout << i << ' '; cout << '\\n';"
    ],
    "description": "print vector"
  },


  
  "input vector": {
    "prefix": "vin",
    "body": [
      "for(auto &i: ${1:a}) cin >> i;"
    ],
    "description": "input vector"
  },

  "Print Map": {
    "prefix": "opmap",
    "body": [
      "for(auto i: ${1:a}) cout << i.first << ' ' << i.second << '\\n';"
    ],
    "description": "Print Map"
  },
  
  "Yes": {
    "prefix": "y",
    "body": [
      "YES"
    ],
    "description": "Yes"
  },

  "No": {   
    "prefix": "n",
    "body": [
      "NO"
    ],
    "description": "No"
  },

  "atcoder": {
    "prefix": "mwe",
    "body": [
      // "// $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "typedef long long ll;",
      "",
      "int32_t main() {",
      "\tios::sync_with_stdio(false); cin.tie(0);",
      "\t$0",
      "}"
    ],
    "description": "atcoder"
  },

  "segment tree": {
    "prefix": "segtree",
    "body": [
      "namespace atc {",
      "namespace internal {",
      "",
      "// @param n `0 <= n`",
      "// @return minimum non-negative `x` s.t. `n <= 2**x`",
      "int ceil_pow2(int n) {",
      "  int x = 0;",
      "  while ((1U << x) < (unsigned int)(n))",
      "    x++;",
      "  return x;",
      "}",
      "",
      "// @param n `1 <= n`",
      "// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`",
      "int bsf(unsigned int n) {",
      "#ifdef _MSC_VER",
      "  unsigned long index;",
      "  _BitScanForward(&index, n);",
      "  return index;",
      "#else",
      "  return __builtin_ctz(n);",
      "#endif",
      "}",
      "",
      "} ",
      "} ",
      "",
      "namespace atc {",
      "",
      "template <class S, S (*op)(S, S), S (*e)()> struct segtree {",
      "public:",
      "  segtree() : segtree(0) {}",
      "  segtree(int n) : segtree(std::vector<S>(n, e())) {}",
      "  segtree(const std::vector<S> &v) : _n(int(v.size())) {",
      "    log = internal::ceil_pow2(_n);",
      "    size = 1 << log;",
      "    d = std::vector<S>(2 * size, e());",
      "    for (int i = 0; i < _n; i++) d[size + i] = v[i];",
      "    for (int i = size - 1; i >= 1; i--) update(i);",
      "  }",
      "",
      "  void set(int p, S x) {",
      "    assert(0 <= p && p < _n); p += size;",
      "    d[p] = x;",
      "    for (int i = 1; i <= log; i++) update(p >> i);",
      "  }",
      "",
      "  S get(int p) {",
      "    assert(0 <= p && p < _n);",
      "    return d[p + size];",
      "  }",
      "",
      "  S prod(int l, int r) {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    S sml = e(), smr = e();",
      "    l += size; r += size;",
      "",
      "    while (l < r) {",
      "      if (l & 1) sml = op(sml, d[l++]);",
      "      if (r & 1) smr = op(d[--r], smr);",
      "      l >>= 1;",
      "      r >>= 1;",
      "    }",
      "    return op(sml, smr);",
      "  }",
      "",
      "  S all_prod() { return d[1]; }",
      "",
      "  template <bool (*f)(S)> int max_right(int l) {",
      "    return max_right(l, [](S x) { return f(x); });",
      "  }",
      "  template <class F> int max_right(int l, F f) {",
      "    assert(0 <= l && l <= _n);",
      "    assert(f(e()));",
      "    if (l == _n) return _n;",
      "    l += size;",
      "    S sm = e();",
      "    do {",
      "      while (l % 2 == 0) l >>= 1;",
      "      if (!f(op(sm, d[l]))) {",
      "        while (l < size) {",
      "          l = (2 * l);",
      "          if (f(op(sm, d[l]))) {",
      "            sm = op(sm, d[l]); l++;",
      "          }",
      "        }",
      "        return l - size;",
      "      }",
      "      sm = op(sm, d[l]); l++;",
      "    } while ((l & -l) != l);",
      "    return _n;",
      "  }",
      "",
      "  template <bool (*f)(S)> int min_left(int r) {",
      "    return min_left(r, [](S x) { return f(x); });",
      "  }",
      "  template <class F> int min_left(int r, F f) {",
      "    assert(0 <= r && r <= _n);",
      "    assert(f(e()));",
      "    if (r == 0) return 0;",
      "    r += size;",
      "    S sm = e();",
      "    do {",
      "      r--;",
      "      while (r > 1 && (r % 2)) r >>= 1;",
      "      if (!f(op(d[r], sm))) {",
      "        while (r < size) { r = (2 * r + 1);",
      "          if (f(op(d[r], sm))) {",
      "            sm = op(d[r], sm); r--;",
      "          }",
      "        }",
      "        return r + 1 - size;",
      "      }",
      "      sm = op(d[r], sm);",
      "    } while ((r & -r) != r);",
      "    return 0;",
      "  }",
      "",
      "private:",
      "  int _n, size, log; std::vector<S> d;",
      "  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
      "};",
      "}",
      "using namespace atc;"
    ],
    "description": "segment tree"
  },

  "Sieve of Eratosthenes": {
    "prefix": "sieve",
    "body": [
      "const int N = 1e5 + 5, M = 2 * N + 5;",
      "",
      "bool vis[N], ans;",
      "",
      "void Sieve() {",
      "  memset(vis, true, sizeof(vis));",
      "",
      "  vis[0] = vis[1] = false;",
      "  for (int i = 4; i < N; i += 2)",
      "    vis[i] = false;",
      "  for (int i = 3; i < N / i; i += 2) {",
      "    if (!vis[i])",
      "      continue;",
      "    for (int j = i * i; j < N; j += i + i)",
      "      vis[j] = false;",
      "  }",
      "}",
      "",
      "int in[N], vid;",
      "vector<int> primes;",
      "",
      "void Gen() {",
      "  for (int i = 2; i < N; ++i)",
      "    if (vis[i])",
      "      primes.emplace_back(i);",
      "}"
    ],
    "description": "Sieve of Eratosthenes"
  },


"usaco io": {
  "prefix": "usaco",
  "body": [
    "void setIO(string name) {",
    "	ios_base::sync_with_stdio(0);",
    "	cin.tie(0);",
    "	if (name.size()) {",
    "		freopen((name + \".in\").c_str(), \"r\", stdin);",
    "		freopen((name + \".out\").c_str(), \"w\", stdout);",
    "	}",
    "}"
  ],
  "description": "usaco io"
},

"factorize": {
  "prefix": "faxx",
  "body": [
    "using u32 = uint32_t;",
    "__attribute__((noinline)) void factor_helper(vector<u32> &vec, u32 &x, u32 y) {",
    "    do {",
    "        vec.push_back(y); x /= y;",
    "    } while (x % y == 0);",
    "}",
    "",
    "constexpr int maxp = 31623; // sqrt(2e9), you can adjust this",
    "constexpr int P = 3401; // number of primes below maxp",
    "",
    "constexpr auto primes = []() constexpr {",
    "    int idx = 0; array<int, P> res{}; array<int, maxp> comp{};",
    "    for (int p = 2; p < maxp; p++) {",
    "        if (!comp[p]) {",
    "            res[idx++] = p;",
    "            for (int j = p; j < maxp; j += p) {",
    "                comp[j] = 1;",
    "            }",
    "        }",
    "    }",
    "    return res;",
    "}();",
    "",
    "template <int L, int R, int M = (L + R) / 2>",
    "__attribute__((always_inline)) constexpr void fact_p(auto &vec, u32 &x) {",
    "    if constexpr (L + 1 < R) {",
    "        fact_p<L, M>(vec, x); fact_p<M, R>(vec, x);",
    "    } else {",
    "        if (x % primes[L] == 0) [[unlikely]] {",
    "            factor_helper(vec, x, primes[L]);",
    "        }",
    "    }",
    "}",
    "",
    "vector<u32> factor(u32 x) {",
    "    vector<u32> vec; fact_p<0, P>(vec, x);",
    "    if (x > 1) vec.push_back(x);",
    "    return vec;",
    "}"
  ],
  "description": "factorize"
},

"Mod Exp ": {
  "prefix": "expmod",
  "body": [
    "ll exp(ll x, ll n, ll m) {",
    "	assert(n >= 0); x %= m;",
    "	ll res = 1;",
    "	while (n > 0) {",
    "		if (n % 2 == 1) { res = res * x % m; }",
    "		x = x * x % m; n /= 2;",
    "	}",
    "	return res;",
    "}"
  ],
  "description": "Mod Exp "
},

"prime factorization": {
  "prefix": "fax",
  "body": [
    "vector<long long> factor(long long n) {",
    "  vector<long long> factorization;",
    "  for (int d : {2, 3, 5}) {",
    "    while (n % d == 0) {",
    "      factorization.push_back(d);",
    "      n /= d;",
    "    }",
    "  }",
    "  static array<int, 8> increments = {4, 2, 4, 2, 4, 6, 2, 6};",
    "  int i = 0;",
    "  for (long long d = 7; d * d <= n; d += increments[i++]) {",
    "    while (n % d == 0) {",
    "      factorization.push_back(d);",
    "      n /= d;",
    "    }",
    "    if (i == 8)",
    "      i = 0;",
    "  }",
    "  if (n > 1)",
    "    factorization.push_back(n);",
    "  return factorization;",
    "}"
  ],
  "description": "prime factorization"
},

"pair prime factors": {
  "prefix": "faxp",
  "body": [
    "vector<pair <ll, ll>> factor(long long n) {",
    "  vector<long long> factorization;",
    "  for (int d : {2, 3, 5}) {",
    "    while (n % d == 0) {",
    "      factorization.push_back(d);",
    "      n /= d;",
    "    }",
    "  }",
    "  static array<int, 8> increments = {4, 2, 4, 2, 4, 6, 2, 6};",
    "  int i = 0;",
    "  for (long long d = 7; d * d <= n; d += increments[i++]) {",
    "    while (n % d == 0) {",
    "      factorization.push_back(d);",
    "      n /= d;",
    "    }",
    "    if (i == 8)",
    "      i = 0;",
    "  }",
    "  if (n > 1) factorization.push_back(n);",
    "  vector <pair <ll, ll>> fx;",
    "  map <ll, ll> pp;",
    "  for(auto i: factorization) pp[i]++;",
    "  for(auto i: pp) fx.push_back({i.first, i.second});",
    "  return fx;",
    "}"
  ],
  "description": "pair prime factors"
},


"Mod Int": {
  "prefix": "mi",
  "body": [
    "const int MOD = 1e9 + 7;",
    "",
    "struct mi {",
    "	int v;",
    "	explicit operator int() const { return v; }",
    "	mi() { v = 0; }",
    "	mi(long long _v) : v(_v % MOD) { v += (v < 0) * MOD; }",
    "};",
    "mi &operator+=(mi &a, mi b) {",
    "	if ((a.v += b.v) >= MOD) a.v -= MOD;",
    "	return a;",
    "}",
    "mi &operator-=(mi &a, mi b) {",
    "	if ((a.v -= b.v) < 0) a.v += MOD;",
    "	return a;",
    "}",
    "mi operator+(mi a, mi b) { return a += b; }",
    "mi operator-(mi a, mi b) { return a -= b; }",
    "mi operator*(mi a, mi b) { return mi((long long)a.v * b.v); }",
    "mi &operator*=(mi &a, mi b) { return a = a * b; }",
    "mi pow(mi a, long long p) {",
    "	assert(p >= 0);",
    "	return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);",
    "}",
    "mi inv(mi a) {",
    "	assert(a.v != 0);",
    "	return pow(a, MOD - 2);",
    "}",
    "mi operator/(mi a, mi b) { return a * inv(b); }"
  ],
  "description": "Mod Int"
},


"i to n": {
  "prefix": "forn",
  "body": [
    "for (int i = 0; i < n; i++)"
  ],
  "description": "i to n"
}




}
